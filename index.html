<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variant Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, minmax(0, 1fr));
            grid-template-rows: repeat(9, minmax(0, 1fr));
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            border: 3px solid #1f2937; /* gray-800 */
            border-radius: 8px;
            gap: 1px;
            background-color: #374151; /* gray-700 */
            position: relative;
        }
        .sudoku-cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f9fafb; /* gray-50 */
            font-size: clamp(1rem, 4vw, 1.5rem); /* Responsive font size */
            font-weight: 500;
            color: #3b82f6; /* blue-500 for user input */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: 1px solid #d1d5db; /* gray-300 */
            z-index: 1;
        }
        .given-cell {
            font-weight: 700;
            color: #1f2937; /* gray-800 for givens */
            cursor: not-allowed;
        }
        .has-value .notes-container {
            display: none;
        }
        .notes-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 2px;
            pointer-events: none;
        }
        .note-digit {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(0.5rem, 2vw, 0.7rem); /* Responsive font size */
            color: #ef4444; /* red-500 */
            font-weight: 700; /* bold */
        }
        #thermo-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        .constraint-icon {
            position: absolute;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
        }
        .even-constraint { background-color: #fca5a5 !important; }
        .odd-constraint { background-color: #93c5fd !important; }
        .yellow-region { background-color: #fef08a !important; }
        
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        /* Numpad Styles */
        #numpad {
            display: none;
            position: absolute;
            z-index: 50;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            width: clamp(140px, 35vw, 180px); /* Responsive width */
        }
        .numpad-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #e5e7eb;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.2s;
            aspect-ratio: 1 / 1; /* Make buttons square */
        }
        .numpad-btn:hover {
            background-color: #f3f4f6;
        }
        .numpad-main {
            font-size: clamp(1rem, 4vw, 1.5rem);
            font-weight: 600;
            color: #3b82f6;
        }
        .numpad-note {
            font-size: clamp(0.7rem, 3vw, 1rem);
            font-weight: 700;
            color: #ef4444;
        }

    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-lg mx-auto">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-gray-800 mb-4">Sudoku Player</h1>
        
        <p id="message-area" class="text-center text-red-600 mb-4 h-6 font-semibold"></p>

        <div id="sudoku-board" class="sudoku-grid mx-auto shadow-lg">
            <svg id="thermo-layer"></svg>
        </div>
        
        <!-- Legend -->
        <div id="legend" class="mt-4 p-3 bg-gray-200 rounded-lg shadow-inner">
            <h4 class="font-bold text-center text-lg text-gray-800 mb-2">Legend</h4>
            <div class="flex flex-wrap justify-center items-center gap-x-2 sm:gap-x-4 gap-y-2 text-xs sm:text-sm">
                <div class="flex items-center gap-2"><div class="w-5 h-5 bg-red-300 rounded-sm border border-gray-400"></div><span>Even</span></div>
                <div class="flex items-center gap-2"><div class="w-5 h-5 bg-blue-300 rounded-sm border border-gray-400"></div><span>Odd</span></div>
                <div class="flex items-center gap-2"><div class="w-5 h-5 bg-yellow-200 rounded-sm border border-gray-400"></div><span>Unique Digits</span></div>
                <div class="flex items-center gap-2"><svg class="w-5 h-5 text-gray-600" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M12 5V19M5 12H19"/></svg><span>Max</span></div>
                <div class="flex items-center gap-2"><svg class="w-5 h-5 text-gray-600" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M5 12H19"/></svg><span>Min</span></div>
                <div class="flex items-center gap-2"><svg class="w-5 h-5 text-green-600" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="8"/></svg><span>Thermometer</span></div>
            </div>
        </div>

        <div class="flex justify-center flex-wrap gap-2 mt-8">
            <button id="back-btn" class="px-6 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Back</button>
            <button id="load-btn" class="px-6 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600">Load Puzzle</button>
            <button id="clear-btn" class="px-6 py-2 bg-gray-800 text-white font-semibold rounded-lg shadow-md hover:bg-gray-900">Clear Inputs</button>
        </div>
    </div>

    <!-- Numpad Popup -->
    <div id="numpad">
        <div class="grid grid-cols-3 gap-1 mb-2">
            <!-- Main numbers will be generated here -->
        </div>
        <div class="grid grid-cols-3 gap-1">
            <!-- Note numbers will be generated here -->
        </div>
        <button id="numpad-erase" class="numpad-btn w-full mt-2 h-10 text-sm font-semibold">Erase</button>
    </div>

    <!-- Load Modal -->
    <div id="modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">Load Puzzle Code</h2>
            <textarea id="modal-textarea" class="w-full h-32 p-2 border rounded-md mb-4 font-mono text-sm" placeholder="Paste your puzzle code here..."></textarea>
            <div class="flex justify-end space-x-2">
                <button id="modal-action-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Load Puzzle</button>
                <button id="modal-close-btn" class="px-4 py-2 bg-gray-300 rounded-md hover:bg-gray-400">Close</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const boardElement = document.getElementById('sudoku-board');
        const messageArea = document.getElementById('message-area');
        const numpad = document.getElementById('numpad');
        const backBtn = document.getElementById('back-btn');
        
        // --- Game State ---
        let givenBoard = [];
        let currentBoard = [];
        let notesBoard = [];
        let moveHistory = [];
        let constraints = {};
        let thermometers = [];
        let activeCell = null;
        const emptyBoard = Array(9).fill().map(() => Array(9).fill(0));

        // --- Game Initialization ---
        function init() {
            givenBoard = emptyBoard.map(row => [...row]);
            currentBoard = emptyBoard.map(row => [...row]);
            notesBoard = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
            moveHistory = [];
            constraints = {};
            thermometers = [];
            createGrid();
            createNumpad();
            addEventListeners();
            updateBackButtonState();
            messageArea.textContent = 'Load a puzzle to begin!';
        }

        function addEventListeners() {
            backBtn.addEventListener('click', undoMove);
            document.getElementById('load-btn').addEventListener('click', showLoadModal);
            document.getElementById('clear-btn').addEventListener('click', () => {
                if (window.confirm("Are you sure? This will clear all your entries and notes.")) {
                    currentBoard = givenBoard.map(row => [...row]);
                    notesBoard = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
                    moveHistory = [];
                    updateBackButtonState();
                    createGrid();
                    messageArea.textContent = 'Board cleared.';
                }
            });
            document.getElementById('modal-close-btn').addEventListener('click', () => document.getElementById('modal').classList.add('hidden'));
            new ResizeObserver(drawThermometers).observe(boardElement);
            document.addEventListener('click', (e) => {
                if (!numpad.contains(e.target) && activeCell && !activeCell.contains(e.target)) {
                    hideNumpad();
                }
            });
        }

        // --- UI Creation ---
        function createGrid() {
            boardElement.innerHTML = '<svg id="thermo-layer"></svg>';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('sudoku-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    const cellText = document.createElement('span');
                    cell.appendChild(cellText);

                    const notesContainer = document.createElement('div');
                    notesContainer.classList.add('notes-container');
                    cell.appendChild(notesContainer);

                    const givenValue = givenBoard[r][c];
                    const currentValue = currentBoard[r][c];

                    if (currentValue !== 0) {
                         cellText.textContent = currentValue;
                         cell.classList.add('has-value');
                         if (givenValue !== 0) {
                            cell.classList.add('given-cell');
                         }
                    } else {
                         cell.addEventListener('click', () => handleCellClick(cell));
                    }
                    
                    updateCellVisuals(cell, r, c);
                    updateNotesVisuals(cell, r, c);
                    boardElement.appendChild(cell);
                }
            }
            requestAnimationFrame(drawThermometers);
        }

        function createNumpad() {
            const mainContainer = numpad.children[0];
            const noteContainer = numpad.children[1];
            mainContainer.innerHTML = '';
            noteContainer.innerHTML = '';

            for (let i = 1; i <= 9; i++) {
                const mainBtn = document.createElement('button');
                mainBtn.textContent = i;
                mainBtn.classList.add('numpad-btn', 'numpad-main');
                mainBtn.addEventListener('click', () => {
                    handleNumberInput(activeCell, parseInt(activeCell.dataset.row), parseInt(activeCell.dataset.col), i);
                    hideNumpad();
                });
                mainContainer.appendChild(mainBtn);

                const noteBtn = document.createElement('button');
                noteBtn.textContent = i;
                noteBtn.classList.add('numpad-btn', 'numpad-note');
                noteBtn.addEventListener('click', () => {
                    handleNoteInput(activeCell, parseInt(activeCell.dataset.row), parseInt(activeCell.dataset.col), i);
                });
                noteContainer.appendChild(noteBtn);
            }
            
            document.getElementById('numpad-erase').addEventListener('click', () => {
                 handleNumberInput(activeCell, parseInt(activeCell.dataset.row), parseInt(activeCell.dataset.col), 0);
                 hideNumpad();
            });
        }

        function updateNotesVisuals(cell, r, c) {
            const notesContainer = cell.querySelector('.notes-container');
            if (!notesContainer) return;
            notesContainer.innerHTML = '';
            const notes = Array.from(notesBoard[r][c]).sort();
            
            const noteElements = Array(9).fill().map(() => {
                const el = document.createElement('div');
                el.classList.add('note-digit');
                return el;
            });

            notes.forEach(note => {
                if (note > 0 && note <= 9) {
                    noteElements[note - 1].textContent = note;
                }
            });
            
            noteElements.forEach(el => notesContainer.appendChild(el));
        }

        // --- Load Logic ---
        function loadPuzzleFromCode(code) {
            try {
                const puzzleData = JSON.parse(atob(code));
                givenBoard = puzzleData.board || emptyBoard.map(row => [...row]);
                currentBoard = givenBoard.map(row => [...row]);
                constraints = puzzleData.constraints || {};
                thermometers = puzzleData.thermometers || [];
                notesBoard = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
                moveHistory = [];
                updateBackButtonState();
                createGrid();
                document.getElementById('modal').classList.add('hidden');
                messageArea.textContent = "Puzzle loaded successfully!";
            } catch (e) {
                alert("Invalid puzzle code.");
            }
        }

        function showLoadModal() {
            const modal = document.getElementById('modal');
            const textarea = document.getElementById('modal-textarea');
            textarea.value = '';
            document.getElementById('modal-action-btn').onclick = () => loadPuzzleFromCode(textarea.value);
            modal.classList.remove('hidden');
        }
        
        // --- Thermometer Drawing ---
        function drawThermometers() {
            const svg = document.getElementById('thermo-layer');
            if (!svg) return;
            svg.innerHTML = '';
            const cellElements = document.querySelectorAll('.sudoku-cell');
            if (cellElements.length === 0 || cellElements[0].offsetWidth === 0) return;

            const cellWidth = cellElements[0].offsetWidth;
            const cellHeight = cellElements[0].offsetHeight;
            const gap = 1;
            const getCenter = (r, c) => ({ x: c * (cellWidth + gap) + cellWidth / 2, y: r * (cellHeight + gap) + cellHeight / 2 });
            const transparentGreen = 'rgba(34, 197, 94, 0.4)';

            thermometers.forEach(path => {
                if (path.length === 0) return;
                if (path.length > 1) {
                    let pathString = `M ${getCenter(path[0][0], path[0][1]).x} ${getCenter(path[0][0], path[0][1]).y}`;
                    for (let i = 1; i < path.length; i++) {
                        pathString += ` L ${getCenter(path[i][0], path[i][1]).x} ${getCenter(path[i][0], path[i][1]).y}`;
                    }
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    line.setAttribute('d', pathString);
                    line.setAttribute('stroke', transparentGreen);
                    line.setAttribute('stroke-width', cellWidth / 2);
                    line.setAttribute('stroke-linecap', 'round');
                    line.setAttribute('stroke-linejoin', 'round');
                    line.setAttribute('fill', 'none');
                    svg.appendChild(line);
                }
                const bulb = getCenter(path[0][0], path[0][1]);
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', bulb.x);
                circle.setAttribute('cy', bulb.y);
                circle.setAttribute('r', cellWidth / 2.5);
                circle.setAttribute('fill', transparentGreen);
                svg.appendChild(circle);
            });
        }
        
        // --- Move History & Undo Logic ---
        function saveState() {
            const state = {
                currentBoard: currentBoard.map(row => [...row]),
                notesBoard: notesBoard.map(row => row.map(cellNotes => new Set(cellNotes)))
            };
            moveHistory.push(state);
            updateBackButtonState();
        }

        function undoMove() {
            if (moveHistory.length === 0) return;
            const lastState = moveHistory.pop();
            currentBoard = lastState.currentBoard;
            notesBoard = lastState.notesBoard;
            createGrid(); // Redraw the entire grid based on the restored state
            updateBackButtonState();
        }

        function updateBackButtonState() {
            backBtn.disabled = moveHistory.length === 0;
        }

        // --- Event Handlers & Logic ---
        function showNumpad(cell) {
            const rect = cell.getBoundingClientRect();
            
            numpad.style.display = 'block';
            const numpadWidth = numpad.offsetWidth;
            const numpadHeight = numpad.offsetHeight;

            let top = rect.bottom;
            let left = rect.left + (rect.width / 2) - (numpadWidth / 2);

            if (left < 0) left = 5;
            if (left + numpadWidth > window.innerWidth) left = window.innerWidth - numpadWidth - 5;
            if (top + numpadHeight > window.innerHeight) top = rect.top - numpadHeight;
            
            numpad.style.top = `${top}px`;
            numpad.style.left = `${left}px`;
        }
        
        function hideNumpad() {
            numpad.style.display = 'none';
            activeCell = null;
        }

        function handleCellClick(cell) {
            if (givenBoard[parseInt(cell.dataset.row)][parseInt(cell.dataset.col)] !== 0) return;
            
            if (activeCell === cell) {
                hideNumpad();
            } else {
                activeCell = cell;
                showNumpad(cell);
            }
        }

        function handleNoteInput(cell, r, c, number) {
            if (currentBoard[r][c] !== 0) return; 

            saveState(); // Save state before changing notes
            const notes = notesBoard[r][c];
            if (notes.has(number)) {
                notes.delete(number);
            } else {
                notes.add(number);
            }
            updateNotesVisuals(cell, r, c);
        }

        function handleNumberInput(cell, r, c, number) {
            const oldBoardValue = currentBoard[r][c];
            if (oldBoardValue === number) return; // No change, do nothing

            const tempBoard = currentBoard.map(row => [...row]);
            tempBoard[r][c] = number;

            const validationMessage = getValidationMessage(tempBoard, r, c, number);

            if (validationMessage) {
                messageArea.textContent = validationMessage;
            } else {
                saveState(); // Save state before making a valid change
                messageArea.textContent = '';
                currentBoard[r][c] = number;
                cell.querySelector('span').textContent = number === 0 ? '' : number;

                if (number !== 0) {
                    cell.classList.add('has-value');
                    notesBoard[r][c].clear();
                    updateNotesVisuals(cell, r, c);
                } else {
                    cell.classList.remove('has-value');
                }
                checkWinCondition();
            }
        }
        
        function checkWinCondition() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (currentBoard[r][c] === 0) return;
                }
            }
            messageArea.style.color = 'green';
            messageArea.textContent = 'Congratulations! You solved the puzzle! ðŸŽ‰';
        }

        // --- User Validation Logic ---
        function getValidationMessage(board, row, col, num) {
            if (num === 0) return null; 

            // Row and Column check
            for (let x = 0; x < 9; x++) {
                if (x !== col && board[row][x] === num) return `Invalid: ${num} is already in this row.`;
                if (x !== row && board[x][col] === num) return `Invalid: ${num} is already in this column.`;
            }

            const key = `${row},${col}`;
            const constraint = constraints[key];

            // Custom constraints check
            if (constraint === 'even' && num % 2 !== 0) return `Invalid: This cell must be even.`;
            if (constraint === 'odd' && num % 2 === 0) return `Invalid: This cell must be odd.`;
            if (constraint === 'yellow') {
                for(let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                    if ((r !== row || c !== col) && constraints[`${r},${c}`] === 'yellow' && board[r][c] === num) {
                        return `Invalid: ${num} is already in the yellow region.`;
                    }
                }
            }
            for (const thermo of thermometers) {
                const thermoIndex = thermo.findIndex(p => p[0] === row && p[1] === col);
                if (thermoIndex !== -1) {
                    if (thermoIndex > 0) {
                        const prevVal = board[thermo[thermoIndex-1][0]][thermo[thermoIndex-1][1]];
                        if (prevVal !== 0 && num <= prevVal) return `Invalid: Must be > ${prevVal} on thermometer.`;
                    }
                    if (thermoIndex < thermo.length - 1) {
                        const nextVal = board[thermo[thermoIndex+1][0]][thermo[thermoIndex+1][1]];
                        if (nextVal !== 0 && num >= nextVal) return `Invalid: Must be < ${nextVal} on thermometer.`;
                    }
                }
            }
            const orthoDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            if (constraint === 'max') {
                for (const [dr, dc] of orthoDirections) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && board[nr][nc] !== 0 && num <= board[nr][nc]) {
                        return `Invalid: This 'Max' cell must be > its neighbor (${board[nr][nc]}).`;
                    }
                }
            }
            if (constraint === 'min') {
                for (const [dr, dc] of orthoDirections) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && board[nr][nc] !== 0 && num >= board[nr][nc]) {
                         return `Invalid: This 'Min' cell must be < its neighbor (${board[nr][nc]}).`;
                    }
                }
            }
             for (const [dr, dc] of orthoDirections) {
                const nr = row + dr, nc = col + dc;
                if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9) {
                    const neighborConstraint = constraints[`${nr},${nc}`];
                    const neighborValue = board[nr][nc];
                    if (neighborValue !== 0) {
                        if (neighborConstraint === 'max' && neighborValue <= num) return `Invalid: Violates neighbor 'Max' rule.`;
                        if (neighborConstraint === 'min' && neighborValue >= num) return `Invalid: Violates neighbor 'Min' rule.`;
                    }
                }
            }

            return null;
        }
        
        // --- Visual Helpers ---
        function updateCellVisuals(cell, r, c) {
            const key = `${r},${c}`;
            const constraint = constraints[key];
            
            const existingIcon = cell.querySelector('.constraint-icon');
            if(existingIcon) cell.removeChild(existingIcon);

            if (constraint === 'max') addVisual(cell, `<svg class="w-full h-full p-1" viewBox="0 0 24 24" fill="none" stroke="rgba(107, 114, 128, 0.5)" stroke-width="3" stroke-linecap="round"><path d="M12 4V20M4 12H20"/></svg>`);
            else if (constraint === 'min') addVisual(cell, `<svg class="w-full h-full p-1" viewBox="0 0 24 24" fill="none" stroke="rgba(107, 114, 128, 0.5)" stroke-width="3" stroke-linecap="round"><path d="M4 12H20"/></svg>`);
            else if (constraint === 'even') cell.classList.add('even-constraint');
            else if (constraint === 'odd') cell.classList.add('odd-constraint');
            else if (constraint === 'yellow') cell.classList.add('yellow-region');
        }

        function addVisual(cell, svgHtml) {
            const icon = document.createElement('div');
            icon.classList.add('constraint-icon');
            icon.innerHTML = svgHtml;
            cell.insertBefore(icon, cell.firstChild);
        }
        
        // --- Start the game ---
        window.onload = init;
    </script>
</body>
</html>
